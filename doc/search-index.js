var N=null,E="",T="t",U="u",searchIndex={};
var R=["labcolor","result"];
searchIndex["slic"]={"doc":"This crate provides simple API to apply Simple Linear…","i":[[3,"Slic","slic","Main SLIC state struct which holds the state for each step…",N,N],[12,"k",E,"result amount of superpixels (clusters).",0,N],[12,"compactness",E,"value between 0-20. balances color proximity and space…",0,N],[12,"slic_zero_mode",E,"run SLIC-zero, the zero compactness parameter mode of SLIC.",0,N],[12,"labels",E,"SLIC result Vec. Labels mask produced on input image. Max…",0,N],[12,"img",E,"reference image target image received in `slic::get_slic`.",0,N],[5,"get_slic",E,"Constructor for [`slic0::Slic`] struct. Produces SLIC…",N,[[["u32"],["f64"],["rgbimage"],["bool"]],["slic"]]],[0,"lab",E,E,N,N],[5,"sub","slic::lab",E,N,[[[R[0]]],[R[0]]]],[5,"rgb_2_lab",E,E,N,[[],[R[0]]]],[6,"LabColor",E,E,N,N],[11,"compute","slic","Mutable methods which runs SLIC computations. Applies…",0,[[["self"]]]],[11,"get_borders_image",E,"Crates 4-channel `image::RgbaImage` with `self.img`…",0,[[["self"]],["rgbaimage"]]],[11,"into",E,E,0,[[],[U]]],[11,"from",E,E,0,[[[T]],[T]]],[11,"try_from",E,E,0,[[[U]],[R[1]]]],[11,"try_into",E,E,0,[[],[R[1]]]],[11,"borrow_mut",E,E,0,[[["self"]],[T]]],[11,"borrow",E,E,0,[[["self"]],[T]]],[11,"type_id",E,E,0,[[["self"]],["typeid"]]]],"p":[[3,"Slic"]]};
initSearch(searchIndex);addSearchOptions(searchIndex);